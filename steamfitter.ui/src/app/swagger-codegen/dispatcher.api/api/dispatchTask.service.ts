/*
Crucible
Copyright 2020 Carnegie Mellon University.
NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
Released under a MIT (SEI)-style license, please see license.txt or contact permission@sei.cmu.edu for full terms.
[DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.  Please see Copyright notice for non-US Government use and distribution.
Carnegie Mellon(R) and CERT(R) are registered in the U.S. Patent and Trademark Office by Carnegie Mellon University.
DM20-0181
*/

/**
 * Steamfitter API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApiError } from '../model/apiError';
import { DispatchTask } from '../model/dispatchTask';
import { DispatchTaskResult } from '../model/dispatchTaskResult';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class DispatchTaskService {

  protected basePath = 'http://localhost';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

      if (configuration) {
          this.configuration = configuration;
          this.configuration.basePath = configuration.basePath || basePath || this.basePath;

      } else {
          this.configuration.basePath = basePath || this.basePath;
      }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
      const form = 'multipart/form-data';
      for (const consume of consumes) {
          if (form === consume) {
              return true;
          }
      }
      return false;
  }


    /**
     * Creates a new DispatchTask and executes it
     * Creates a new DispatchTask with the attributes specified and executes it  &lt;para /&gt;  Accessible only to a SuperUser or an Administrator
     * @param dispatchTask The data to create the DispatchTask with
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createAndExecuteDispatchTask(dispatchTask?: DispatchTask, observe?: 'body', reportProgress?: boolean): Observable<DispatchTaskResult[]>;
    public createAndExecuteDispatchTask(dispatchTask?: DispatchTask, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DispatchTaskResult[]>>;
    public createAndExecuteDispatchTask(dispatchTask?: DispatchTask, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DispatchTaskResult[]>>;
    public createAndExecuteDispatchTask(dispatchTask?: DispatchTask, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DispatchTask>(`${this.configuration.basePath}/dispatchtasks/execute`,
            dispatchTask,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new DispatchTask
     * Creates a new DispatchTask with the attributes specified  &lt;para /&gt;  Accessible only to a SuperUser or an Administrator
     * @param dispatchTask The data to create the DispatchTask with
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDispatchTask(dispatchTask?: DispatchTask, observe?: 'body', reportProgress?: boolean): Observable<DispatchTask>;
    public createDispatchTask(dispatchTask?: DispatchTask, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DispatchTask>>;
    public createDispatchTask(dispatchTask?: DispatchTask, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DispatchTask>>;
    public createDispatchTask(dispatchTask?: DispatchTask, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DispatchTask>(`${this.configuration.basePath}/dispatchtasks`,
            dispatchTask,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Copyies a new DispatchTask
     * Copies a new DispatchTask with the attributes specified  &lt;para /&gt;  Accessible only to a SuperUser or an Administrator
     * @param newLocation The data to create the DispatchTask with
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public copyDispatchTask(id: string, newLocation?: any, observe?: 'body', reportProgress?: boolean): Observable<DispatchTask[]>;
    public copyDispatchTask(id: string, newLocation?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DispatchTask[]>>;
    public copyDispatchTask(id: string, newLocation?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DispatchTask[]>>;
    public copyDispatchTask(id: string, newLocation?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DispatchTask>(`${this.configuration.basePath}/dispatchtasks/${encodeURIComponent(String(id))}/copy`,
            newLocation,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a DispatchTask
     * Deletes a DispatchTask with the specified id  &lt;para /&gt;  Accessible only to a SuperUser or a User on an Admin Team within the specified DispatchTask
     * @param id The id of the DispatchTask to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteDispatchTask(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteDispatchTask(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteDispatchTask(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteDispatchTask(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDispatchTask.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/dispatchtasks/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Executes a specific DispatchTask by id
     * Executes the DispatchTask with the id specified  &lt;para /&gt;  Accessible to a SuperUser or administrator
     * @param id The id of the DispatchTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public executeDispatchTask(id: string, observe?: 'body', reportProgress?: boolean): Observable<DispatchTaskResult[]>;
    public executeDispatchTask(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DispatchTaskResult[]>>;
    public executeDispatchTask(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DispatchTaskResult[]>>;
    public executeDispatchTask(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling executeDispatchTask.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.post<DispatchTask>(`${this.configuration.basePath}/dispatchtasks/${encodeURIComponent(String(id))}/execute`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all possible DispatchTask commands
     * Returns a list of all of the DispatchTask commands.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAvailableCommands(observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getAvailableCommands(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getAvailableCommands(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getAvailableCommands(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<string>(`${this.configuration.basePath}/dispatchtasks/commands`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific DispatchTask by id
     * Returns the DispatchTask with the id specified  &lt;para /&gt;  Accessible to a SuperUser or a User that is a member of a Team within the specified DispatchTask
     * @param id The id of the DispatchTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDispatchTask(id: string, observe?: 'body', reportProgress?: boolean): Observable<DispatchTask>;
    public getDispatchTask(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DispatchTask>>;
    public getDispatchTask(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DispatchTask>>;
    public getDispatchTask(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDispatchTask.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<DispatchTask>(`${this.configuration.basePath}/dispatchtasks/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all DispatchTask in the system
     * Returns a list of all of the DispatchTasks in the system.  &lt;para /&gt;  Only accessible to a SuperUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDispatchTasks(observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getDispatchTasks(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getDispatchTasks(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getDispatchTasks(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/dispatchtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all DispatchTasks for an Exercise
     * Returns all DispatchTasks for the specified Exercise
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExerciseDispatchTasks(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getExerciseDispatchTasks(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getExerciseDispatchTasks(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getExerciseDispatchTasks(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getExerciseDispatchTasks.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/exercises/${encodeURIComponent(String(id))}/dispatchtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all manual DispatchTasks for the current User
     * Returns all manual DispatchTasks for the current User
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMyDispatchTasks(observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getMyDispatchTasks(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getMyDispatchTasks(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getMyDispatchTasks(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/me/dispatchtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all DispatchTasks for a Scenario
     * Returns all DispatchTasks for the specified Scenario
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getScenarioDispatchTasks(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getScenarioDispatchTasks(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getScenarioDispatchTasks(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getScenarioDispatchTasks(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getScenarioDispatchTasks.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/scenarios/${encodeURIComponent(String(id))}/dispatchtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all DispatchTasks for a Session
     * Returns all DispatchTasks for the specified Session
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSessionDispatchTasks(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getSessionDispatchTasks(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getSessionDispatchTasks(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getSessionDispatchTasks(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSessionDispatchTasks.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/sessions/${encodeURIComponent(String(id))}/dispatchtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all DispatchTasks for a Trigger Task (Parent)
     * Returns all DispatchTasks for the specified TriggerTask
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSubtasks(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getSubtasks(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getSubtasks(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getSubtasks(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubtasks.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/dispatchtasks/${encodeURIComponent(String(id))}/subtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all manual DispatchTasks for a User
     * Returns all manual DispatchTasks for the specified User
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserDispatchTasks(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getUserDispatchTasks(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getUserDispatchTasks(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getUserDispatchTasks(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserDispatchTasks.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/users/${encodeURIComponent(String(id))}/dispatchtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all DispatchTasks for a VM
     * Returns all DispatchTasks for the specified VM
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVmDispatchTasks(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DispatchTask>>;
    public getVmDispatchTasks(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DispatchTask>>>;
    public getVmDispatchTasks(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DispatchTask>>>;
    public getVmDispatchTasks(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVmDispatchTasks.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<DispatchTask>>(`${this.configuration.basePath}/vms/${encodeURIComponent(String(id))}/dispatchtasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a DispatchTask
     * Updates a DispatchTask with the attributes specified  &lt;para /&gt;  Accessible only to a SuperUser or a User on an Admin Team within the specified DispatchTask
     * @param id The Id of the Exericse to update
     * @param dispatchTask The updated DispatchTask values
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateDispatchTask(id: string, dispatchTask?: DispatchTask, observe?: 'body', reportProgress?: boolean): Observable<DispatchTask>;
    public updateDispatchTask(id: string, dispatchTask?: DispatchTask, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DispatchTask>>;
    public updateDispatchTask(id: string, dispatchTask?: DispatchTask, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DispatchTask>>;
    public updateDispatchTask(id: string, dispatchTask?: DispatchTask, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDispatchTask.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<DispatchTask>(`${this.configuration.basePath}/dispatchtasks/${encodeURIComponent(String(id))}`,
            dispatchTask,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Moves a DispatchTask
     * Moves a DispatchTask with the attributes specified  &lt;para /&gt;  Accessible only to a SuperUser or a User on an Admin Team within the specified DispatchTask
     * @param id The Id of the Exericse to move
     * @param newLocation The Id and type of the new location
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveDispatchTask(id: string, newLocation?: any, observe?: 'body', reportProgress?: boolean): Observable<DispatchTask[]>;
    public moveDispatchTask(id: string, newLocation?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DispatchTask[]>>;
    public moveDispatchTask(id: string, newLocation?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DispatchTask[]>>;
    public moveDispatchTask(id: string, newLocation?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling moveDispatchTask.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/dispatchtasks/${encodeURIComponent(String(id))}/move`,
            newLocation,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

